SQL INJECTIONS
--------------

Inj.1 - Retriving hidden data
.............................

- Assuming a website with URL: https://insecure-website.com/products?category=Gifts'--
This results in a particular SQL query: SELECT * FROM products WHERE category = 'Gifts'--' AND released = 1

- What exactly is the '--'?
A -- is an SQL comment. Anything after this in a query is not applied.
We can also view products in categories that the attacker doesn't know about AKA

https://insecure-website.com/products?category=Gifts' + OR + 1=1--

This will return all items.

Inj.2 - Subverting application logic
....................................

- If an app uses a SQL where query to check for username and password, 
an attacker can inject a '--' after the username check to ignore the
password check. 

Inj.3 - Retriving data from other database tables
.................................................

- Never return an SQL query as an application response because this lets
attackers use the UNION keyword i.e. an additional SQL query.

query: SELECT name, description FROM products WHERE category = 'Gifts'
injection: ' UNION SELECT username, password FROM users--

First order injection = application takes user input for HTTP request and processes the input as SQL statement and executes it
Second order injection = application takes user input for HTTP request but stores it in a DB. While performing a different
request, the original is taken from the DB and is executed. 

Authentication
--------------

- Remember, the host parameter in the web is the request originator. 

Auth.1 - Username enumeration and password brute forcing
........................................................

- Always return the same status code for an incorrect username/password combination. Some websites return a different status
code for one, which will lead the attacker to believe one was correct. Same with error messages and response times (tricky eh?)
- The OWASP ZAP fuzzer is great for this

Directory Traversal
-------------------

Dir.1 Reading arbitrary files
.............................

- If an image is attached from the /var/www/images folder using a path parameter like loadfile?img1.png, a ../../../etc/passwd
can be attached to obtain and read the password file from the server.
- If a website strips file traversal operations, you can use nested file traversals which'll work after the outer ones get
stripped. Example - ...../ or something like that. These sanitations can sometimes also be bypassed by URL encoding the
traversal characters.
- There are literally thousands of situations and attacks possible, as this tutorial shows. For instance, a particularly
interesting one is: if an application requires the filename to end in .jpg, you could do a file traversal with a null-byte
at the end i.e. ../../../etc/passwd%00.png (null byte ends the string)
- Just don't let user-supplied information affect the filesystem.

OS Command Injection
--------------------

OCI.1 Executing arbitrary commands
..................................

- & is the shell command seperator. So, if you know that a certain feature is using shell commands, try injecting input such as
command & echo "Using shell commands" to test OS command injection.
- If an API endpoint takes in parameters, try injecting OS commands like echo or whoami in there. However, for some reason, the
parameter only was injectable by giving it one valid argument and then a | OS_command_here. 
- Knowing that system is vulnerable to this kind of injection can be destructive/informative (you can find out tons of 
info about the system)
- If the system doesn't return any information about a shell command being run, this is a blind command injection.

So this begs the question, how would you detect these?

OCI.2 Ways to inject blind OS command injection
...............................................

TIME DELAYS

- The ping command in linux allows you to send a certain number of ICMP packets. Not sure how this makes it happen, but it'll
create a time delay and thereby allow you to know whether a command was run or not.

REDIRECTING OUTPUT

- Since most systems don't return the output given by OS commands, you can add additional redirection commands to determine when
a blind OS command injection is possible.

There's a bunch of characters which you can inject into vulnerable spots to elicit reactions from the server like &, |, `, etc.
All this is also dependent on the kind of system being used.

Best way of protection: never call OS level commands from application code.

Broken Access Control
---------------------

- This is a vulnerability which takes advantage of different resources being available for different groups, with not enough
controls for securing it. 

Example - the admin site not being locked down properly

BAC.1 Broken access control resulting from platform misconfiguration
....................................................................

- Some applications deny endpoints at the platform level, which may be overriden by some sepcial request headers. If a
skiller hacker knows this, he'll take advantage of it.
- A good way to find vulnerabilites is to make tons of requests through ZAP, add the website to your context if you have to,
and just search through everything to find the kind of response you want, whether it be cookies, the actual response, the request
or whatever.

Note of the day - the key in security/hacking is to be carefully open-minded to a robotic level; your answer could lie literally
anywhere, so be prepared to check anywhere, everywhere, all at once.

- User id's controller by parameters are obviously insecure
- User id's passed in by unpredictable UUID's are also insecure as they may be revealed elsewhere, like in comments, likes, or
whatever else

- Insecure direct object references is when the server stores objects (such as chat logs), which may be taken advantage of.
- The Referrer header is added by website to show which request originated from where (particularly which page). If there's
an area of the website which only needs to originate from a particular place, and there's no other access control available
besides the Referrer headers, well.. zannen desune.

File upload vulnerabilities
---------------------------

- When creating an uploading functionality, at the very least, you should be validating the name, type, content, and size of the
file, among other things.

FUV.1 Exploiting unrestricted file uploads to deploy a web shell
................................................................

- A simple example is uploading a php file which prints out the system's id. After the upload, the file is requested for using a
GET, and it triggers the script to run.

FUV.2 Exploiting flawed validation of file uploads
..................................................

Normal form data: application/x-www-form-url-encoded
Binary form data: multipart/form-data

- Form data is broken into Content-Dispositions i.e. squiggly lines and some data about what the field
is and its name (this is of course hidden to you, but you can view them if you view the actual source
in Chrome Devtools or Postman). Sometimes these individual fields have a ContentType header which may
be what the website or server checks as validation. These values shouldn't be blindly trusted because,
as we've seen, they can easily be changeable by using OWASP Zap or Burp Suite.

- Sometimes, the server will be configured to only execute files of a certain type, so even if a php/js
file slips through the cracks, it'll return the file text or an error as response. Generally, user
directories as much more securely locked down, so if you use directory travsersal and upload the file
to a directory implicitly considered secure, you might be able to run the script.

- Your requests will often be handled by additional servers behind the scenes, which may also be configured 
differently.

- Blacklisting filetypes doesn't work as people will always find weird filetypes which can be executable.
- Even if servers blacklist some types of files, if a malicious config file (like an Apache .htaccess) is
uploaded, the blacklist will count for naught (who even talks like that?) Another thing that can mess
with extension blacklists is to mess around (the best way I could put it). For instance - 
file.php.jpg, file%2Ephp, etc.

- Secure servers don't trust the Content-Type header and try to validate that the contents of the file
matches what extension is expected. How is it done? Checking to see if the inner content has some
attributes of what we'd expect the file type to have. Apparently jpeg files always have the same set of
bytes in the beginning.

Using ExifTool, you can inject malicious code into file metadata.

- Since the PUT request method gives you the ability to modify resources, you better be sure your
backend handles that well, as it is basically an upload.

- A whitelist is more useful than a blacklist in this case.

Server Side Request Forgery
---------------------------

An SSRF attack is basically re-rerouting an HTTP request back to itself using the loopback network
interface i.e. 127.0.0.1 or localhost. Sometimes, if there are sections of the application
unaccesible by unauthorized users, an SSRF attack may trick the system into thinking that the
request came from itself, thereby bypassing the normal logic which checks against this sort of thing.

- In the challenge to perform an SSRF attack against the server, you changed the request to be
localhost/admin which let us find the admin API to delete a user. Trying the delete button
straight from the UI didn't let us do it. But then, we found the actual endpoint which does the
deletion, which was .../admin/deleteUser?id=id. Using the stockAPI request parameter and passing
in the loopback network URL with the associated endpoint let us perform the deletion with no issue!

- 172 and 192 are private IP addresses. SSRF can also be used to take advantage of internal backend
systems.
- Blacklisting IPs is also a kiddie move, as IPs seem to have alternate representations or registering
your own domain name to be 127.0.0.1 (o.O).
- Even whitelists can be confused by adding in URL special characters like @, #, and other things that
leverage networking, like the DNS naming hierarchy.

SSRF.1 Bypassing SSRF filters via open redirection
..................................................

- Suppose a website contains a URL which is validated for SSRF but still has the open redirection
vulnerability. What happens here?
Construct a valid URL which then redirects the request to the desired backend target.

URL - /product/nextProduct?currentProductId=6&path=http://evil-user.net
Redirect - http://evil-user.net
Request to exploit vulnerability - 

    POST /product/stock HTTP/1.0
    Content-Type: application/x-www-form-urlencoded
    Content-Length: 118

    stockApi=http://weliketoshop.net/product/nextProduct?currentProductId=6&path=http://192.168.0.68/admin

The moment you see a request parameter with a full URL, your eyes and ears should perk up because there
may be an SSRF vulnerability there. But blind ones are tough because the app returns no response to
take advantage of.

XML external entity (XXE) injection
-----------------------------------